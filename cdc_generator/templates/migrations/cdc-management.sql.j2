-- ============================================================================
-- DO NOT EDIT — AUTO-GENERATED by: cdc manage-migrations generate
-- Generated: {{ generated_at }}
-- ============================================================================
-- CDC Management Infrastructure: merge control, processing log, monitoring.
-- Deployed once per target database into the "cdc_management" schema.
-- Sink target: {{ sink_target.sink_name }}
-- All identifiers are double-quoted for safety.
-- ============================================================================

-- ============================================================================
-- 1. MERGE CONTROL (event-driven staging → final table merge)
-- ============================================================================

CREATE SCHEMA IF NOT EXISTS "cdc_management";

CREATE UNLOGGED TABLE IF NOT EXISTS "cdc_management"."merge_control" (
    "schema_name"       TEXT     NOT NULL,
    "table_name"        TEXT     NOT NULL,
    "has_changes"       BOOLEAN  NOT NULL DEFAULT FALSE,
    "is_merging"        BOOLEAN  NOT NULL DEFAULT FALSE,
    "last_merge_at"     TIMESTAMPTZ,
    "last_change_at"    TIMESTAMPTZ,
    "merge_count"       BIGINT   NOT NULL DEFAULT 0,
    "total_rows_merged" BIGINT   NOT NULL DEFAULT 0,
    "error_count"       INT      NOT NULL DEFAULT 0,
    "last_error"        TEXT,
    PRIMARY KEY ("schema_name", "table_name")
);

-- Error log for merge failures
CREATE TABLE IF NOT EXISTS "cdc_management"."error_log" (
    "id"          BIGSERIAL PRIMARY KEY,
    "schema_name" TEXT        NOT NULL,
    "table_name"  TEXT        NOT NULL,
    "error_msg"   TEXT        NOT NULL,
    "occurred_at" TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS "idx_error_log_occurred"
    ON "cdc_management"."error_log" ("occurred_at" DESC);

-- ============================================================================
-- 2. TRIGGER FUNCTION: mark staging table for merge
-- ============================================================================
-- Called by AFTER INSERT triggers on staging tables.
-- Extracts table name by stripping "stg_" prefix.

CREATE OR REPLACE FUNCTION "cdc_management"."mark_table_for_merge"()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    v_table TEXT;
BEGIN
    v_table := regexp_replace(TG_TABLE_NAME, '^stg_', '');

    INSERT INTO "cdc_management"."merge_control" ("schema_name", "table_name", "has_changes", "last_change_at")
    VALUES (TG_TABLE_SCHEMA, v_table, TRUE, NOW())
    ON CONFLICT ("schema_name", "table_name")
    DO UPDATE SET
        "has_changes"    = TRUE,
        "last_change_at" = NOW();

    RETURN NULL;
END;
$$;

-- ============================================================================
-- 3. MERGE ORCHESTRATOR: trigger_pending_merges()
-- ============================================================================
-- Called by pg_cron (or manually). Finds tables with pending changes older
-- than the batch window, then calls the per-table sp_merge_<table>() procedure.

CREATE OR REPLACE FUNCTION "cdc_management"."trigger_pending_merges"(
    p_batch_window_seconds INT DEFAULT 5
)
RETURNS TABLE("schema_name" TEXT, "table_name" TEXT, "rows_merged" BIGINT, "duration_ms" DOUBLE PRECISION)
LANGUAGE plpgsql
AS $$
DECLARE
    v_rec RECORD;
    v_start TIMESTAMPTZ;
    v_rows  BIGINT;
    v_proc  TEXT;
BEGIN
    FOR v_rec IN
        SELECT mc."schema_name", mc."table_name"
        FROM "cdc_management"."merge_control" mc
        WHERE mc."has_changes" = TRUE
          AND mc."is_merging" = FALSE
          AND mc."last_change_at" < NOW() - (p_batch_window_seconds || ' seconds')::INTERVAL
        ORDER BY mc."last_change_at"
    LOOP
        -- Mark as merging
        UPDATE "cdc_management"."merge_control"
        SET "is_merging" = TRUE
        WHERE "cdc_management"."merge_control"."schema_name" = v_rec."schema_name"
          AND "cdc_management"."merge_control"."table_name"  = v_rec."table_name";

        v_start := clock_timestamp();
        v_proc  := format('%I.sp_merge_%s', v_rec."schema_name", lower(v_rec."table_name"));

        BEGIN
            EXECUTE format('CALL %s()', v_proc);

            -- Count merged rows (from staging, now 0 after TRUNCATE)
            v_rows := 0;

            UPDATE "cdc_management"."merge_control"
            SET "is_merging"       = FALSE,
                "has_changes"      = FALSE,
                "last_merge_at"    = NOW(),
                "merge_count"      = "merge_count" + 1,
                "total_rows_merged"= "total_rows_merged" + v_rows
            WHERE "cdc_management"."merge_control"."schema_name" = v_rec."schema_name"
              AND "cdc_management"."merge_control"."table_name"  = v_rec."table_name";

            "schema_name" := v_rec."schema_name";
            "table_name"  := v_rec."table_name";
            "rows_merged" := v_rows;
            "duration_ms" := EXTRACT(MILLISECONDS FROM clock_timestamp() - v_start);
            RETURN NEXT;

        EXCEPTION WHEN OTHERS THEN
            UPDATE "cdc_management"."merge_control"
            SET "is_merging"  = FALSE,
                "error_count" = "error_count" + 1,
                "last_error"  = SQLERRM
            WHERE "cdc_management"."merge_control"."schema_name" = v_rec."schema_name"
              AND "cdc_management"."merge_control"."table_name"  = v_rec."table_name";

            INSERT INTO "cdc_management"."error_log" ("schema_name", "table_name", "error_msg")
            VALUES (v_rec."schema_name", v_rec."table_name", SQLERRM);
        END;
    END LOOP;
END;
$$;

-- ============================================================================
-- 4. PROCESSING LOG (offset tracking, gap detection, replication lag)
-- ============================================================================

CREATE TABLE IF NOT EXISTS "cdc_management"."cdc_processing_log" (
    "id"                 BIGSERIAL    PRIMARY KEY,
    "schema_name"        TEXT         NOT NULL,
    "table_name"         TEXT         NOT NULL,
    "min_source_ts_ms"   BIGINT,
    "max_source_ts_ms"   BIGINT,
    "min_kafka_offset"   BIGINT,
    "max_kafka_offset"   BIGINT,
    "kafka_partition"    INT,
    "records_processed"  INT          NOT NULL DEFAULT 0,
    "merge_duration_ms"  INT,
    "processed_at"       TIMESTAMPTZ  NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS "idx_cdc_log_gap"
    ON "cdc_management"."cdc_processing_log" ("table_name", "kafka_partition", "min_kafka_offset");

CREATE INDEX IF NOT EXISTS "idx_cdc_log_recent"
    ON "cdc_management"."cdc_processing_log" ("processed_at" DESC);

CREATE INDEX IF NOT EXISTS "idx_cdc_log_time_range"
    ON "cdc_management"."cdc_processing_log" ("table_name", "min_source_ts_ms", "max_source_ts_ms");

-- ============================================================================
-- 5. MIGRATION HISTORY (track which migrations have been applied)
-- ============================================================================

CREATE TABLE IF NOT EXISTS "cdc_management"."migration_history" (
    "id"           BIGSERIAL    PRIMARY KEY,
    "file_name"    TEXT         NOT NULL,
    "checksum"     TEXT         NOT NULL,
    "schema_name"  TEXT,
    "category"     TEXT         NOT NULL,
    "applied_at"   TIMESTAMPTZ  NOT NULL DEFAULT NOW(),
    UNIQUE ("file_name", "schema_name")
);

-- ============================================================================
-- 6. MONITORING VIEWS
-- ============================================================================

CREATE OR REPLACE VIEW "cdc_management"."v_merge_status" AS
SELECT
    mc."schema_name",
    mc."table_name",
    mc."has_changes",
    mc."is_merging",
    mc."last_merge_at",
    mc."last_change_at",
    mc."merge_count",
    mc."total_rows_merged",
    mc."error_count",
    mc."last_error",
    CASE
        WHEN mc."is_merging"  THEN 'MERGING'
        WHEN mc."has_changes" THEN 'PENDING'
        ELSE 'IDLE'
    END AS "status"
FROM "cdc_management"."merge_control" mc
ORDER BY mc."last_change_at" DESC NULLS LAST;

CREATE OR REPLACE VIEW "cdc_management"."v_recent_errors" AS
SELECT "schema_name", "table_name", "error_msg", "occurred_at"
FROM "cdc_management"."error_log"
ORDER BY "occurred_at" DESC
LIMIT 100;

CREATE OR REPLACE VIEW "cdc_management"."v_cdc_processing_gaps" AS
SELECT
    "table_name",
    "kafka_partition",
    "max_kafka_offset"                                                AS "batch_end_offset",
    LEAD("min_kafka_offset") OVER (
        PARTITION BY "table_name", "kafka_partition"
        ORDER BY "min_kafka_offset"
    )                                                                 AS "next_batch_start",
    LEAD("min_kafka_offset") OVER (
        PARTITION BY "table_name", "kafka_partition"
        ORDER BY "min_kafka_offset"
    ) - "max_kafka_offset" - 1                                        AS "gap_size",
    "processed_at"
FROM "cdc_management"."cdc_processing_log"
WHERE "kafka_partition" IS NOT NULL;

CREATE OR REPLACE VIEW "cdc_management"."v_cdc_replication_lag" AS
SELECT
    "table_name",
    "kafka_partition",
    "max_source_ts_ms",
    EXTRACT(EPOCH FROM NOW()) * 1000 - "max_source_ts_ms"             AS "lag_ms",
    "records_processed",
    "processed_at"
FROM "cdc_management"."cdc_processing_log"
WHERE "max_source_ts_ms" IS NOT NULL
ORDER BY "processed_at" DESC;

-- ============================================================================
-- 7. UTILITY: manual_merge()
-- ============================================================================

CREATE OR REPLACE FUNCTION "cdc_management"."manual_merge"(
    p_schema TEXT,
    p_table  TEXT
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
    EXECUTE format('CALL %I.sp_merge_%s()', p_schema, lower(p_table));

    UPDATE "cdc_management"."merge_control"
    SET "has_changes"  = FALSE,
        "last_merge_at"= NOW(),
        "merge_count"  = "merge_count" + 1
    WHERE "schema_name" = p_schema
      AND "table_name"  = p_table;
END;
$$;

-- ============================================================================
-- 8. PERMISSIONS
-- ============================================================================

GRANT USAGE  ON SCHEMA "cdc_management" TO "{{ db_user }}";
GRANT SELECT ON ALL TABLES    IN SCHEMA "cdc_management" TO "{{ db_user }}";
GRANT INSERT ON ALL TABLES    IN SCHEMA "cdc_management" TO "{{ db_user }}";
GRANT UPDATE ON "cdc_management"."merge_control" TO "{{ db_user }}";
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA "cdc_management" TO "{{ db_user }}";
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA "cdc_management" TO "{{ db_user }}";
